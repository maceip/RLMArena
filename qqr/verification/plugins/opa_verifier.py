"""
OPA Verifier Plugin for infrastructure policy enforcement.

This plugin integrates with Open Policy Agent (OPA) to enforce Rego policies
on infrastructure code (Terraform, Kubernetes YAML) generated by agents.
"""

from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Callable, Optional
import json
import re

from qqr.verification.plugin import VerificationPlugin, VerificationResult, VerificationStatus


class PolicySeverity(Enum):
    """Severity levels for policy violations."""
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"


@dataclass
class RegoRule:
    """A single Rego rule within a policy."""
    name: str
    body: str
    severity: PolicySeverity = PolicySeverity.ERROR
    message_template: Optional[str] = None


@dataclass
class RegoPolicy:
    """
    A Rego policy for infrastructure validation.

    Rego is the policy language used by Open Policy Agent (OPA).
    It enables declarative policy definitions over structured data.
    """
    package: str
    rules: list[RegoRule]
    imports: list[str] = field(default_factory=list)
    description: Optional[str] = None

    def to_rego_string(self) -> str:
        """Convert to Rego policy language."""
        lines = [f"package {self.package}", ""]

        for imp in self.imports:
            lines.append(f"import {imp}")

        if self.imports:
            lines.append("")

        for rule in self.rules:
            lines.append(f"# {rule.name}")
            lines.append(rule.body)
            lines.append("")

        return "\n".join(lines)


@dataclass
class PolicyViolation:
    """A detected policy violation."""
    rule: str
    message: str
    severity: PolicySeverity
    resource_path: Optional[str] = None
    resource_type: Optional[str] = None
    details: dict[str, Any] = field(default_factory=dict)


class OPAPolicyEngine:
    """
    Mock OPA policy engine for Rego policy evaluation.

    In production, this would interface with the OPA binary or server.
    This mock provides Python-based evaluation for common policy patterns.
    """

    def __init__(self):
        self.policies: dict[str, RegoPolicy] = {}
        self._rule_evaluators: dict[str, Callable] = {}
        self._register_builtin_evaluators()

    def _register_builtin_evaluators(self) -> None:
        """Register built-in policy evaluators."""
        # Terraform resource checks
        self._rule_evaluators["no_public_s3"] = self._check_no_public_s3
        self._rule_evaluators["encrypted_ebs"] = self._check_encrypted_ebs
        self._rule_evaluators["no_hardcoded_secrets"] = self._check_no_hardcoded_secrets
        self._rule_evaluators["vpc_required"] = self._check_vpc_required
        self._rule_evaluators["tags_required"] = self._check_tags_required

        # Kubernetes checks
        self._rule_evaluators["no_privileged_containers"] = self._check_no_privileged
        self._rule_evaluators["resource_limits_required"] = self._check_resource_limits
        self._rule_evaluators["no_host_network"] = self._check_no_host_network
        self._rule_evaluators["no_latest_tag"] = self._check_no_latest_tag

    def add_policy(self, policy: RegoPolicy) -> None:
        """Add a policy to the engine."""
        self.policies[policy.package] = policy

    def evaluate(
        self,
        data: dict[str, Any],
        data_type: str = "terraform",
    ) -> list[PolicyViolation]:
        """
        Evaluate data against all registered policies.

        Args:
            data: The infrastructure data to evaluate (Terraform JSON, K8s manifest, etc.)
            data_type: Type of data being evaluated ("terraform", "kubernetes", "generic")

        Returns:
            List of policy violations detected
        """
        violations = []

        for package, policy in self.policies.items():
            for rule in policy.rules:
                evaluator = self._rule_evaluators.get(rule.name)
                if evaluator:
                    rule_violations = evaluator(data, rule, data_type)
                    violations.extend(rule_violations)

        return violations

    def _check_no_public_s3(
        self,
        data: dict[str, Any],
        rule: RegoRule,
        data_type: str,
    ) -> list[PolicyViolation]:
        """Check for public S3 buckets in Terraform."""
        violations = []

        if data_type != "terraform":
            return violations

        resources = data.get("resource", {})
        s3_buckets = resources.get("aws_s3_bucket", {})

        for name, config in s3_buckets.items():
            acl = config.get("acl", "private")
            if acl in ("public-read", "public-read-write", "authenticated-read"):
                violations.append(PolicyViolation(
                    rule=rule.name,
                    message=f"S3 bucket '{name}' has public ACL: {acl}",
                    severity=rule.severity,
                    resource_path=f"aws_s3_bucket.{name}",
                    resource_type="aws_s3_bucket",
                    details={"acl": acl},
                ))

        # Check for public access block being disabled
        public_access = resources.get("aws_s3_bucket_public_access_block", {})
        for name, config in public_access.items():
            if not config.get("block_public_acls", True):
                violations.append(PolicyViolation(
                    rule=rule.name,
                    message=f"S3 bucket public access block '{name}' allows public ACLs",
                    severity=rule.severity,
                    resource_path=f"aws_s3_bucket_public_access_block.{name}",
                    resource_type="aws_s3_bucket_public_access_block",
                ))

        return violations

    def _check_encrypted_ebs(
        self,
        data: dict[str, Any],
        rule: RegoRule,
        data_type: str,
    ) -> list[PolicyViolation]:
        """Check for unencrypted EBS volumes."""
        violations = []

        if data_type != "terraform":
            return violations

        resources = data.get("resource", {})
        ebs_volumes = resources.get("aws_ebs_volume", {})

        for name, config in ebs_volumes.items():
            if not config.get("encrypted", False):
                violations.append(PolicyViolation(
                    rule=rule.name,
                    message=f"EBS volume '{name}' is not encrypted",
                    severity=rule.severity,
                    resource_path=f"aws_ebs_volume.{name}",
                    resource_type="aws_ebs_volume",
                ))

        return violations

    def _check_no_hardcoded_secrets(
        self,
        data: dict[str, Any],
        rule: RegoRule,
        data_type: str,
    ) -> list[PolicyViolation]:
        """Check for hardcoded secrets in configuration."""
        violations = []

        secret_patterns = [
            (r'(?i)password\s*[=:]\s*["\'][^"\']{8,}["\']', "hardcoded password"),
            (r'(?i)api[_-]?key\s*[=:]\s*["\'][^"\']{16,}["\']', "hardcoded API key"),
            (r'(?i)secret\s*[=:]\s*["\'][^"\']{8,}["\']', "hardcoded secret"),
            (r'AKIA[0-9A-Z]{16}', "AWS access key"),
            (r'(?i)private[_-]?key', "private key reference"),
        ]

        data_str = json.dumps(data)

        for pattern, secret_type in secret_patterns:
            matches = re.findall(pattern, data_str)
            for match in matches:
                violations.append(PolicyViolation(
                    rule=rule.name,
                    message=f"Potential {secret_type} detected in configuration",
                    severity=PolicySeverity.CRITICAL,
                    details={"pattern": pattern, "match_preview": match[:50] + "..."},
                ))

        return violations

    def _check_vpc_required(
        self,
        data: dict[str, Any],
        rule: RegoRule,
        data_type: str,
    ) -> list[PolicyViolation]:
        """Check that EC2 instances are in a VPC."""
        violations = []

        if data_type != "terraform":
            return violations

        resources = data.get("resource", {})
        instances = resources.get("aws_instance", {})

        for name, config in instances.items():
            if not config.get("subnet_id") and not config.get("vpc_security_group_ids"):
                violations.append(PolicyViolation(
                    rule=rule.name,
                    message=f"EC2 instance '{name}' may not be in a VPC",
                    severity=rule.severity,
                    resource_path=f"aws_instance.{name}",
                    resource_type="aws_instance",
                ))

        return violations

    def _check_tags_required(
        self,
        data: dict[str, Any],
        rule: RegoRule,
        data_type: str,
    ) -> list[PolicyViolation]:
        """Check that resources have required tags."""
        violations = []

        if data_type != "terraform":
            return violations

        required_tags = ["Environment", "Owner", "Project"]
        resources = data.get("resource", {})

        taggable_types = ["aws_instance", "aws_s3_bucket", "aws_vpc", "aws_subnet"]

        for resource_type in taggable_types:
            type_resources = resources.get(resource_type, {})
            for name, config in type_resources.items():
                tags = config.get("tags", {})
                missing = [t for t in required_tags if t not in tags]
                if missing:
                    violations.append(PolicyViolation(
                        rule=rule.name,
                        message=f"Resource '{name}' missing required tags: {missing}",
                        severity=PolicySeverity.WARNING,
                        resource_path=f"{resource_type}.{name}",
                        resource_type=resource_type,
                        details={"missing_tags": missing},
                    ))

        return violations

    def _check_no_privileged(
        self,
        data: dict[str, Any],
        rule: RegoRule,
        data_type: str,
    ) -> list[PolicyViolation]:
        """Check for privileged containers in Kubernetes."""
        violations = []

        if data_type != "kubernetes":
            return violations

        containers = self._extract_containers(data)
        for path, container in containers:
            security_context = container.get("securityContext", {})
            if security_context.get("privileged", False):
                violations.append(PolicyViolation(
                    rule=rule.name,
                    message=f"Container '{container.get('name', 'unnamed')}' runs as privileged",
                    severity=PolicySeverity.CRITICAL,
                    resource_path=path,
                    resource_type="container",
                ))

        return violations

    def _check_resource_limits(
        self,
        data: dict[str, Any],
        rule: RegoRule,
        data_type: str,
    ) -> list[PolicyViolation]:
        """Check that containers have resource limits."""
        violations = []

        if data_type != "kubernetes":
            return violations

        containers = self._extract_containers(data)
        for path, container in containers:
            resources = container.get("resources", {})
            if not resources.get("limits"):
                violations.append(PolicyViolation(
                    rule=rule.name,
                    message=f"Container '{container.get('name', 'unnamed')}' has no resource limits",
                    severity=rule.severity,
                    resource_path=path,
                    resource_type="container",
                ))

        return violations

    def _check_no_host_network(
        self,
        data: dict[str, Any],
        rule: RegoRule,
        data_type: str,
    ) -> list[PolicyViolation]:
        """Check for host network usage in Kubernetes."""
        violations = []

        if data_type != "kubernetes":
            return violations

        spec = data.get("spec", {})
        if isinstance(spec, dict):
            pod_spec = spec.get("template", {}).get("spec", spec)
            if pod_spec.get("hostNetwork", False):
                violations.append(PolicyViolation(
                    rule=rule.name,
                    message="Pod uses host network",
                    severity=PolicySeverity.CRITICAL,
                    resource_path="spec.hostNetwork",
                    resource_type="pod",
                ))

        return violations

    def _check_no_latest_tag(
        self,
        data: dict[str, Any],
        rule: RegoRule,
        data_type: str,
    ) -> list[PolicyViolation]:
        """Check for 'latest' image tags in Kubernetes."""
        violations = []

        if data_type != "kubernetes":
            return violations

        containers = self._extract_containers(data)
        for path, container in containers:
            image = container.get("image", "")
            if image.endswith(":latest") or ":" not in image:
                violations.append(PolicyViolation(
                    rule=rule.name,
                    message=f"Container '{container.get('name', 'unnamed')}' uses 'latest' or untagged image",
                    severity=rule.severity,
                    resource_path=path,
                    resource_type="container",
                    details={"image": image},
                ))

        return violations

    def _extract_containers(self, data: dict[str, Any]) -> list[tuple[str, dict]]:
        """Extract all containers from a Kubernetes manifest."""
        containers = []

        def extract_from_spec(spec: dict, path: str) -> None:
            for container in spec.get("containers", []):
                containers.append((f"{path}.containers", container))
            for container in spec.get("initContainers", []):
                containers.append((f"{path}.initContainers", container))

        spec = data.get("spec", {})

        # Deployment/ReplicaSet/etc with template
        template_spec = spec.get("template", {}).get("spec", {})
        if template_spec:
            extract_from_spec(template_spec, "spec.template.spec")

        # Pod directly
        if spec.get("containers"):
            extract_from_spec(spec, "spec")

        return containers


class OPAVerifierPlugin(VerificationPlugin):
    """
    Verification plugin that enforces Rego policies on infrastructure code.

    This plugin:
    1. Extracts Terraform/K8s code from trajectory
    2. Parses it into structured data
    3. Evaluates against Rego policies
    4. Fails trajectory if critical violations found
    """

    def __init__(
        self,
        policies: Optional[list[RegoPolicy]] = None,
        fail_on_warning: bool = False,
        custom_rules: Optional[dict[str, Callable]] = None,
    ):
        self._policies = policies or []
        self._fail_on_warning = fail_on_warning
        self._engine = OPAPolicyEngine()

        # Register policies
        for policy in self._policies:
            self._engine.add_policy(policy)

        # Register custom rule evaluators
        if custom_rules:
            self._engine._rule_evaluators.update(custom_rules)

    @property
    def name(self) -> str:
        return "opa_verifier"

    @property
    def description(self) -> str:
        return "Enforces Rego policies on infrastructure code (Terraform, Kubernetes)"

    @property
    def is_hard_check(self) -> bool:
        return True

    @property
    def floor_reward(self) -> float:
        return -1.0

    def add_policy(self, policy: RegoPolicy) -> None:
        """Add a Rego policy at runtime."""
        self._engine.add_policy(policy)

    def _extract_infrastructure_code(
        self,
        messages: list[dict[str, Any]],
    ) -> list[tuple[str, dict[str, Any], int]]:
        """
        Extract infrastructure code blocks from messages.

        Returns list of (data_type, parsed_data, message_index) tuples.
        """
        extracted = []

        for i, msg in enumerate(messages):
            content = msg.get("content", "")
            if not isinstance(content, str):
                continue

            # Extract Terraform HCL/JSON blocks
            tf_blocks = self._extract_code_blocks(content, ["terraform", "hcl", "tf"])
            for block in tf_blocks:
                parsed = self._parse_terraform(block)
                if parsed:
                    extracted.append(("terraform", parsed, i))

            # Extract Kubernetes YAML/JSON blocks
            k8s_blocks = self._extract_code_blocks(content, ["yaml", "kubernetes", "k8s"])
            for block in k8s_blocks:
                parsed = self._parse_kubernetes(block)
                if parsed:
                    extracted.append(("kubernetes", parsed, i))

            # Extract generic JSON that might be infrastructure
            json_blocks = self._extract_code_blocks(content, ["json"])
            for block in json_blocks:
                parsed = self._parse_json(block)
                if parsed:
                    # Guess the type based on content
                    if "resource" in parsed or "provider" in parsed:
                        extracted.append(("terraform", parsed, i))
                    elif "apiVersion" in parsed or "kind" in parsed:
                        extracted.append(("kubernetes", parsed, i))
                    else:
                        extracted.append(("generic", parsed, i))

        return extracted

    def _extract_code_blocks(self, content: str, languages: list[str]) -> list[str]:
        """Extract code blocks with specific language tags."""
        blocks = []
        lang_pattern = "|".join(re.escape(lang) for lang in languages)
        pattern = rf"```(?:{lang_pattern})\s*\n(.*?)```"

        matches = re.findall(pattern, content, re.DOTALL | re.IGNORECASE)
        blocks.extend(matches)

        return blocks

    def _parse_terraform(self, code: str) -> Optional[dict[str, Any]]:
        """Parse Terraform HCL to a dict structure (simplified)."""
        # This is a simplified parser - production would use pyhcl2
        try:
            # Try JSON first (Terraform JSON format)
            return json.loads(code)
        except json.JSONDecodeError:
            pass

        # Simplified HCL parsing for common patterns
        result = {"resource": {}, "provider": {}, "variable": {}}

        # Extract resource blocks
        resource_pattern = r'resource\s+"(\w+)"\s+"(\w+)"\s*\{([^}]+)\}'
        for match in re.finditer(resource_pattern, code, re.DOTALL):
            resource_type, resource_name, body = match.groups()
            if resource_type not in result["resource"]:
                result["resource"][resource_type] = {}
            result["resource"][resource_type][resource_name] = self._parse_hcl_body(body)

        if not result["resource"]:
            return None

        return result

    def _parse_hcl_body(self, body: str) -> dict[str, Any]:
        """Parse HCL block body (simplified)."""
        result = {}

        # Simple key = value parsing
        kv_pattern = r'(\w+)\s*=\s*(?:"([^"]*)"|(true|false)|(\d+)|(\[[^\]]*\])|\{([^}]*)\})'
        for match in re.finditer(kv_pattern, body):
            key = match.group(1)
            if match.group(2) is not None:
                result[key] = match.group(2)
            elif match.group(3) is not None:
                result[key] = match.group(3) == "true"
            elif match.group(4) is not None:
                result[key] = int(match.group(4))
            elif match.group(5) is not None:
                try:
                    result[key] = json.loads(match.group(5).replace("'", '"'))
                except:
                    result[key] = match.group(5)
            elif match.group(6) is not None:
                result[key] = self._parse_hcl_body(match.group(6))

        # Parse tags block specially
        tags_pattern = r'tags\s*=\s*\{([^}]+)\}'
        tags_match = re.search(tags_pattern, body)
        if tags_match:
            tags = {}
            for kv in re.finditer(r'(\w+)\s*=\s*"([^"]*)"', tags_match.group(1)):
                tags[kv.group(1)] = kv.group(2)
            result["tags"] = tags

        return result

    def _parse_kubernetes(self, code: str) -> Optional[dict[str, Any]]:
        """Parse Kubernetes YAML to a dict structure."""
        try:
            # Try JSON first
            return json.loads(code)
        except json.JSONDecodeError:
            pass

        # Simple YAML-like parsing (production would use pyyaml)
        try:
            import yaml
            return yaml.safe_load(code)
        except:
            pass

        # Very basic YAML parsing fallback
        result = {}
        current_key = None
        indent_stack = [(0, result)]

        for line in code.split("\n"):
            stripped = line.lstrip()
            if not stripped or stripped.startswith("#"):
                continue

            indent = len(line) - len(stripped)

            # Pop indent stack
            while indent_stack and indent <= indent_stack[-1][0]:
                indent_stack.pop()

            current_dict = indent_stack[-1][1] if indent_stack else result

            if ":" in stripped:
                key, value = stripped.split(":", 1)
                key = key.strip()
                value = value.strip()

                if value:
                    # Key-value pair
                    if value.startswith('"') and value.endswith('"'):
                        current_dict[key] = value[1:-1]
                    elif value.lower() in ("true", "false"):
                        current_dict[key] = value.lower() == "true"
                    elif value.isdigit():
                        current_dict[key] = int(value)
                    else:
                        current_dict[key] = value
                else:
                    # Nested object
                    current_dict[key] = {}
                    indent_stack.append((indent + 2, current_dict[key]))

        return result if result else None

    def _parse_json(self, code: str) -> Optional[dict[str, Any]]:
        """Parse JSON code block."""
        try:
            return json.loads(code)
        except json.JSONDecodeError:
            return None

    async def verify(
        self,
        messages: list[dict[str, Any]],
        metadata: Optional[dict[str, Any]] = None,
    ) -> VerificationResult:
        """Verify trajectory against Rego infrastructure policies."""
        extracted = self._extract_infrastructure_code(messages)

        if not extracted:
            return VerificationResult(
                status=VerificationStatus.PASSED,
                plugin_name=self.name,
                message="No infrastructure code detected in trajectory",
            )

        all_violations = []
        for data_type, data, msg_index in extracted:
            violations = self._engine.evaluate(data, data_type)
            for v in violations:
                v.details["message_index"] = msg_index
            all_violations.extend(violations)

        # Filter by severity
        critical_errors = [v for v in all_violations if v.severity in (PolicySeverity.ERROR, PolicySeverity.CRITICAL)]
        warnings = [v for v in all_violations if v.severity == PolicySeverity.WARNING]

        if critical_errors or (self._fail_on_warning and warnings):
            return VerificationResult(
                status=VerificationStatus.FAILED,
                plugin_name=self.name,
                message=f"Policy violations: {len(critical_errors)} errors, {len(warnings)} warnings",
                details={
                    "violations": [
                        {
                            "rule": v.rule,
                            "message": v.message,
                            "severity": v.severity.value,
                            "resource_path": v.resource_path,
                            "details": v.details,
                        }
                        for v in all_violations
                    ],
                    "total_code_blocks": len(extracted),
                },
                score_modifier=-1.0,
            )

        return VerificationResult(
            status=VerificationStatus.PASSED,
            plugin_name=self.name,
            message=f"Verified {len(extracted)} infrastructure code block(s), {len(warnings)} warnings",
            details={
                "code_blocks_checked": len(extracted),
                "warnings": [{"rule": v.rule, "message": v.message} for v in warnings],
            },
        )


# Preset policy sets
TERRAFORM_SECURITY_POLICY = RegoPolicy(
    package="terraform.security",
    rules=[
        RegoRule(name="no_public_s3", body="", severity=PolicySeverity.CRITICAL),
        RegoRule(name="encrypted_ebs", body="", severity=PolicySeverity.ERROR),
        RegoRule(name="no_hardcoded_secrets", body="", severity=PolicySeverity.CRITICAL),
        RegoRule(name="vpc_required", body="", severity=PolicySeverity.ERROR),
        RegoRule(name="tags_required", body="", severity=PolicySeverity.WARNING),
    ],
    description="Security policies for Terraform infrastructure",
)

KUBERNETES_SECURITY_POLICY = RegoPolicy(
    package="kubernetes.security",
    rules=[
        RegoRule(name="no_privileged_containers", body="", severity=PolicySeverity.CRITICAL),
        RegoRule(name="resource_limits_required", body="", severity=PolicySeverity.ERROR),
        RegoRule(name="no_host_network", body="", severity=PolicySeverity.CRITICAL),
        RegoRule(name="no_latest_tag", body="", severity=PolicySeverity.WARNING),
    ],
    description="Security policies for Kubernetes manifests",
)
